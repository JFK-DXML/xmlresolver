plugins {
  id "java"
  id "maven-publish"
  id "signing"
  id 'com.github.gmazzo.buildconfig' version "2.0.2"
  id 'com.nwalsh.saxon-gradle' version '0.9.1-beta3'
}

repositories {
  mavenLocal()
  mavenCentral()
  maven { url "https://maven.restlet.com" }
}

java {
  registerFeature('validating') {
    usingSourceSet(sourceSets.main)
  }
}

configurations.all {
  resolutionStrategy {
    force 'xml-apis:xml-apis:1.4.01'
  }
}

configurations {
  standaloneClasspath.extendsFrom(testImplementation)
}

dependencies {
  implementation (
    [group: 'org.apache.httpcomponents', name: 'httpclient', version: '4.5.5'],
    [group: 'org.apache.httpcomponents', name: 'httpcore', version: '4.4.9'],
    [group: 'xml-apis', name: 'xml-apis', version: '1.4.01' ],
    [group: 'org.slf4j', name: 'slf4j-api', version: '1.7.25' ],
    [group: 'org.jetbrains', name: 'annotations', version: '20.1.0' ]
  )

  validatingImplementation (
    [group: 'org.relaxng', name: 'jing', version: '20181222' ]
  )

  testImplementation (
    [group: 'junit', name: 'junit', version: '4.12'],
    [group: 'org.apache.logging.log4j', name: 'log4j-slf4j-impl', version: '2.1'],
    [group: 'org.apache.logging.log4j', name: 'log4j-core', version: '2.1'],
    files("src/test/resources/data1.jar"),
    files("src/test/resources/data2.jar"),
    files("src/test/resources/xmlresolver-data.jar")
  )
}

import com.nwalsh.SaxonXsltTask
import Docker

ext {
  c_restest = "restest"
}

def EXCP="${projectDir}/build/classes/java/main"
configurations.standaloneClasspath.each { it ->
  // Explicitly remove the http libraries
  if (!it.toString().contains("http")) {
    EXCP += ":" + it
  }
}

buildConfig {
  packageName("org.xmlresolver")
  buildConfigField('String', 'appName', "\"org.xmlresolver\"")
  buildConfigField('String', 'VERSION', "\"${resolverVersion}\"")
}

// ============================================================

task stageData(type: SaxonXsltTask) {
  def baselen = "${projectDir}/src/data".length() + 1
  def baseout = "${buildDir}/data/org/xmlresolver"

  inputs.files fileTree(dir: "${projectDir}/src/data")
  outputs.files fileTree(dir: "${projectDir}/src/data").collect { source ->
    "${baseout}/${source.getAbsolutePath().substring(baselen)}"
  }
  outputs.file "${baseout}/cat-entities.xml"
  outputs.file "${baseout}/cat-mathml2.xml"
  outputs.file "${baseout}/cat-mathml3.xml"
  outputs.file "${baseout}/cat-rddl.xml"
  outputs.file "${baseout}/cat-svg.xml"
  outputs.file "${baseout}/cat-xhtml.xml"

  doFirst {
    copy {
      into "${buildDir}/data/org/xmlresolver"
      from ("${projectDir}/src/data") {
        exclude "manifest.xml"
      }
    }
  }

  input "${projectDir}/src/data/manifest.xml"
  output "${buildDir}/data/org/xmlresolver/catalog.xml"
  stylesheet "${projectDir}/tools/make-catalog.xsl"
}

// ============================================================

jar {
  exclude("org/xmlresolver/apps/**")
  archiveBaseName = "${basename}-${resolverVersion}"
  manifest {
    attributes "Built-By": "Norman Walsh"
    attributes "Implementation-Vendor": "Norman Walsh"
    attributes "Implementation-Title": "XML Resolver"
    attributes "Implementation-Version": resolverVersion
  }
}

task appJar(type: Jar) {
  from (sourceSets.main.output) {
    include("org/xmlresolver/apps/**")
  }
  archiveBaseName = "${basename}-apps-${resolverVersion}"
  manifest {
    attributes "Built-By": "Norman Walsh"
    attributes "Implementation-Vendor": "Norman Walsh"
    attributes "Implementation-Title": "XML Resolver applications"
    attributes "Implementation-Version": resolverVersion
  }
}
assemble.dependsOn appJar

task copyJars(type: Copy, dependsOn: ["jar", "appJar"]) {
  from "build/libs"
  into "build/${basename}-${resolverVersion}/lib"
  doFirst {
    mkdir "build/${basename}-${resolverVersion}/lib"
  }
}

task copyDocs(type: Copy) {
  from "${projectDir}/docs"
  into "build/${basename}-${resolverVersion}/"
  filter { String line ->
    if (line.indexOf("@@") >= 0) {
      line = line
        .replace("@@VERSION@@", resolverVersion)
    }
    line
  }
  doFirst {
    mkdir "build/${basename}-${resolverVersion}"
  }
}

task dist(dependsOn: ["copyDocs", "copyJars", "test"], type: Zip) {
  from("build/${basename}-${resolverVersion}")
  into 'xmlresolver-' + resolverVersion
  archiveFileName = "xmlresolver-${resolverVersion}.zip"
}

javadoc {
  title 'XML Catalog Resolver API'
  exclude 'org/xmlresolver/utils/**'
  exclude 'org/xmlresolver/BuildConfig.java'
  exclude 'org/xmlresolver/ResourceConnection.java'
  exclude 'org/xmlresolver/cache/CacheEntryCatalog.java'
  exclude 'org/xmlresolver/catalog/**'
  options.showFromPublic()
  options.overview = 'src/main/java/overview.html'
  options.encoding('utf-8')
  options.docEncoding('utf-8')
  options.charSet('utf-8')
}

task javadocJar(type: Jar, dependsOn: javadoc) {
  archiveFileName = "xmlresolver-javadoc-${resolverVersion}.zip"
  classifier = 'javadoc'
  from javadoc.destinationDir
  manifest {
    attributes "Built-By": "Norman Walsh"
    attributes "Implementation-Vendor": "Norman Walsh"
    attributes "Implementation-Title": "XML Resolver API documentation"
    attributes "Implementation-Version": resolverVersion
  }
}
assemble.dependsOn javadocJar

task sourcesJar(type: Jar, dependsOn: ["generateBuildConfig"]) {
  archiveFileName = "xmlresolver-sources-${resolverVersion}.zip"
  classifier = 'sources'
  from sourceSets.main.allSource
  manifest {
    attributes "Built-By": "Norman Walsh"
    attributes "Implementation-Vendor": "Norman Walsh"
    attributes "Implementation-Title": "XML Resolver sources"
    attributes "Implementation-Version": resolverVersion
  }
}
assemble.dependsOn sourcesJar

task dataJar(type: Jar, dependsOn: ["stageData"]) {
  archiveFileName = "xmlresolver-data-${resolverVersion}.jar"
  classifier = 'data'
  from "${buildDir}/data"
  manifest {
    attributes "Built-By": "Norman Walsh"
    attributes "Implementation-Vendor": "Norman Walsh"
    attributes "Implementation-Title": "XML Resolver data"
    attributes "Implementation-Version": resolverVersion
  }
}
assemble.dependsOn dataJar

signing {
  sign publishing.publications
}

publishing {
  publications {
    mavenJava(MavenPublication) {
      pom {
        name = 'XML Resolver'
        packaging = 'jar'
        description = 'An XML entity/uri resolver'
        url = 'https://github.com/xmlresolver/xmlresolver'

        scm {
          url = 'scm:git@github.com:xmlresolver/xmlresolver.git'
          connection = 'scm:git@github.com:xmlresolver/xmlresolver.git'
          developerConnection = 'scm:git@github.com:xmlresolver/xmlresolver.git'
        }

        licenses {
          license {
            name = 'Apache License version 2.0'
            url = 'https://www.apache.org/licenses/LICENSE-2.0'
            distribution = 'repo'
          }
        }

        developers {
          developer {
            id = 'ndw'
            name = 'Norman Walsh'
          }
        }
      }

      artifactId = basename
      version = resolverVersion
      from components.java
      artifact javadocJar
      artifact sourcesJar
      artifact dataJar
    }
  }

  repositories {
    maven {
      url = resolverVersion.contains("SNAPSHOT") ?
        "https://oss.sonatype.org/content/repositories/snapshots/" :
        "https://oss.sonatype.org/service/local/staging/deploy/maven2/"
      credentials {
        username = findProperty("sonatypeUsername") ?: ""
        password = findProperty("sonatypePassword") ?: ""
      }
    }
  }
}

// Test that the resolver can function without the http client
// libraries on the classpath. You don't get caching, obviously,
// but you also don't get a runtime exception!
task standaloneTest(type: Exec, dependsOn: ["compileJava"]) {
  commandLine "java",
    "-Dlog4j.configurationFile=/Users/ndw/java/log4j2-debug.xml",
    "-cp", EXCP, "org.xmlresolver.apps.Parse",
    "-c", "src/test/resources/catalog.xml",
    "-s", "src/test/resources/doc.xml"
}

task deleteBuild() {
  delete "build"
}

clean.dependsOn deleteBuild

// ======================================================================

tasks.register("dockerup") {
  doLast {
    Docker.assertRunning(c_restest)
  }
}

tasks.register("dockerdown") {
  doLast {
    Docker.assertNotRunning(c_restest)
  }
}

tasks.register("start") {
  dependsOn "dockerdown"

  doFirst {
    Docker.assertDockerAvailable()
    Docker.assertDockerComposeAvailable()
  }

  doLast {
    exec {
      workingDir "docker"
      commandLine Docker.dockerCompose(), "up", "-d"
    }
    exec {
      commandLine Docker.docker(), "ps", "-a", "--format={{.ID}} {{.Names}} {{.Status}}"
    }
  }
}

tasks.register("stop") {
  doFirst {
    Docker.assertDockerComposeAvailable()
  }    

  doLast {
    exec {
      workingDir "docker"
      commandLine Docker.dockerCompose(), "down"
    }
  }
}

// ======================================================================

task helloWorld() {
  // My task for testing
  doLast {
    println("Hello, world.")
  }
}
